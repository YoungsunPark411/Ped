# -*- coding: cp949 -*-
'''
Ycmds
note:
date: 21.09.07
'''
import pymel.core as pm, pymel.core.datatypes as dt, maya.cmds as mc
#General-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

def eqDistanceCurveDivide(curvename,segmentcurveLength):
    curveLength=pm.arclen(curvename)

    uVale=1.0/(segmentcurveLength-1)
    i=0
    posList=[]
    for x in range(segmentcurveLength):
        pointA=pm.pointOnCurve(curvename,top=True, pr=i, p=True )
        posList.append(pointA)
        i=i+uVale
    return posList


def spine_joint_make(curve_Name,spineName,joint_count,joint_start_n,type,ojVal='xzy',sawoVal='xdown'):
    jointParentName=[]
    jointPosition=eqDistanceCurveDivide(curve_Name,joint_count)

    jointList=[]
    mc.select(cl=1)
    mc.select(cl=1)
    for x in jointPosition:
        createName='%s%s%sJnt'%(spineName,str(joint_start_n).zfill(1),type)
        jointList.append(createName)
        mc.joint(p=x,n=createName)
        joint_start_n+=1
    if jointList:
        mc.select(jointList[0]);
        mc.makeIdentity (apply=1,t =0,r= 1 ,s =0 ,n =0 ,pn= 1);
        mc.joint(e=1  ,oj ='xzy' ,secondaryAxisOrient= 'zdown',ch =1 ,zso=1);
        mc.setAttr ("%s.jointOrientX"%jointList[-1], 0);
        mc.setAttr ("%s.jointOrientY"%jointList[-1], 0);
        mc.setAttr ("%s.jointOrientZ"%jointList[-1], 0);
        mc.select(jointList)



    return jointList

def NameExtraction(curve1):
    cn = curve1
    side = []
    ob = []
    if 'Left' in cn:
        side = 'Left'
    elif 'Right' in cn:
        side = 'Right'
    elif 'Up' in cn:
        side = 'Up'
    elif 'Dn' in cn:
        side = 'Dn'
    else:
        side = ''
    obList=['Arm','UpArm','DnArm','Leg','UpLeg','DnLeg','Clavicle','Neck','Spine','Thumb','Index','Middle','Ring','Pinky','Eye','Tongue']
    for i in range(len(obList)):
        if obList[i] in cn:
            ob = obList[i]
        else:
            pass

    if 'Arm' in ob:
        subOb = ['Shoulder', 'Elbow', 'Wrist']
    elif 'Leg' in ob:
        subOb = ['Thigh', 'Knee', 'Ankle']
    else:
        subOb =''

    list=[side,ob,subOb]
    return list

def GrpMake():
    RigGrp = pm.createNode('transform', n='side_ob_RigGrp')
    CtrlGrp = pm.createNode('transform', n='side_ob_CtrlGrp')
    RigSysGrp = pm.createNode('transform', n='side_ob_RigSysGrp')
    EtcGrp = pm.createNode('transform', n='side_ob_EtcGrp')
    GrpList = [RigGrp, CtrlGrp, RigSysGrp, EtcGrp]
    pm.parent(CtrlGrp, RigSysGrp, EtcGrp, RigGrp)
    return GrpList

def JntMake(AllCurve,segNumber, Type):
    pm.rebuildCurve(AllCurve, ch=1, rpo=1, rt=0, end=1, kr=0, kcp=0, kep=1, kt=0, s=segNumber, d=3, tol=0.01)
    JntList=spine_joint_make(curve_Name=AllCurve, spineName='%s'%(AllCurve.split('_')[0]), joint_count=segNumber, joint_start_n=0,type= Type)
    return JntList

def NameChange():
    sideList=pm.ls('side_*')
    for x in sideList:
        pm.rename(x,x.replace('side_',side))
    obList=pm.ls('*ob_*')
    for x in sideList:
        pm.rename(x,x.replace('ob_',ob))

def scaleGet():
    if not pm.objExists('Global'):
        Scale=3
    else:
        Scale = pm.getAttr('Global.scaleX')
    return Scale

# Wcms-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Curve Shape Change
def CurveCenterPiv(crv):
    vtxNum = crv.cp.get(mi=1)
    vtxSz = len(vtxNum)
    mn = [0.0, 0.0, 0.0]
    mx = [0.0, 0.0, 0.0]
    vtxXfm = []
    for i in range(vtxSz):
        vtxXfm.append(pm.xform('%s.cv[%d]' % (crv, vtxNum[i]), q=1, ws=1, t=1))
        bfr = []
        [bfr.append(vtxXfm[i][ii]) for ii in range(3)]
        if i == 0:
            mn[0] = bfr[0]
            mn[1] = bfr[1]
            mn[2] = bfr[2]
            mx[0] = bfr[0]
            mx[1] = bfr[1]
            mx[2] = bfr[2]
        if mn[0] > bfr[0]: mn[0] = bfr[0]
        if mn[1] > bfr[1]: mn[1] = bfr[1]
        if mn[2] > bfr[2]: mn[2] = bfr[2]
        if mx[0] < bfr[0]: mx[0] = bfr[0]
        if mx[1] < bfr[1]: mx[1] = bfr[1]
        if mx[2] < bfr[2]: mx[2] = bfr[2]
    cntVec = []
    i1 = 0
    [cntVec.append((mx[i1] + mn[i1]) / 2) for i1 in range(3)]
    return cntVec





def ChangeCurveTransform(crv, type, transVec, pvt=0):
    pm.select(crv)
    ct=pm.ls(sl=1)
    if 'EyeCtrl' or 'ThickSquare' or 'RoundSquare'in ct:
        span = len(crv.getCVs())
    else:
        span = crv.spans.get()
    deg = crv.d.get()
    endCv = span - 1 if deg == 3 else span
    cntPiv = CurveCenterPiv(crv) if pvt == 0 else crv.getTranslation(space='world')      
    pm.scale(crv.cv, transVec, r=1, p=cntPiv)

    
   
 
# Control Maker
def ChangeCurveColor(crv, colorNum=0):
    crvSh = crv.listRelatives(s=1)[0]
    crvSh.overrideEnabled.set(1)
    crvSh.overrideColor.set(colorNum)
    crv.v.set(l=1)
    crvSh.rename('%sShape' % crv)


def ControlMaker(name, form, colorNum, exGrp=False, size=1.0):
    rst = [None, None]

    if form == 'circle':
        rst[0] = pm.circle(n=name, c=[0, 0, 0], nr=[0, 1, 0], sw=360, r=1, d=3, ut=0, tol=0.01, s=8, ch=0)[0]


    elif form == 'cross':
        rst[0] = pm.curve(d=1, n=name, p=[(-0.332874, 0, -0.332874), (-0.332874, 0, -0.998623), (0.332874, 0, -0.998623), (0.332874, 0, -0.332874),
                                          (0.998623, 0, -0.332874), (0.998623, 0, 0.332874), (0.332874, 0, 0.332874), (0.332874, 0, 0.998623),
                                          (-0.332874, 0, 0.998623), (-0.332874, 0, 0.332874), (-0.998623, 0, 0.332874), (-0.998623, 0, -0.332874), (-0.332874, 0, -0.332874)],
                          k=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])

    elif form == 'square':
        rst[0] = pm.curve(d=1, n=name, p=[(-1, 0, 1), (1, 0, 1), (1, 0, -1), (-1, 0, -1), (-1, 0, 1)], k=[0, 1, 2, 3, 4])
    elif form == 'reverscheck':
        rst[0] = pm.curve(d=1, n=name, p=[(-0.999454, 0, 0.637922), (-0.490766, 0, 0.637922), (0, 0, -0.133233), (0.490766, 0, 0.637922),
                                          (0.999454, 0, 0.637922), (0, 0, -0.86126), (-0.999454, 0, 0.637922)],
                          k=[0, 1, 2, 3, 4, 5, 6])
    elif form == 'diamond':
        rst[0] = pm.curve(d=1, n=name, p=[(0, 0, -1.414214), (-1.414214, 0, 0), (0, 0, 1.414214), (1.414214, 0, 0), (0, 0, -1.414214)], k=[0, 1, 2, 3, 4])
    elif form == 'check':
        rst[0] = pm.curve(d=1, n=name, p=[(0, 0, 0), (-1.255324, 0, -1.255324), (-0.627662, 0, -1.882986), (0, 0, -1.255324), (0.627662, 0, -1.882986), (1.255324, 0, -1.255324), (0, 0, 0)],
                          k=[0, 1, 2, 3, 4, 5, 6])
    elif form == 'switch':
        rst[0] = pm.curve(d=1, n=name, p=[(-0.270729, 0, -0.217609), (-0.270729, 0, -0.454896), (-0.988736, 0, 0.217609), (0.270729, 0, 0.217609), (0.270729, 0, 0.454896), (0.988736, 0, -0.217609), (-0.270729, 0, -0.217609)], k=[0, 1, 2, 3, 4, 5, 6])
    elif form == 'pyramid':
        rst[0] = pm.curve(d=1, n=name, p=[(-0.497381, 0, 0), (0, 0, 0.49738), (0.497381, 0, 0), (0, 0, -0.49738), (-0.497381, 0, 0), (0, 0.642429, 0), (0, 0, 0.49738), (0.497381, 0, 0), (0, 0.642429, 0), (0, 0, -0.49738)], k=(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))
    elif form == 'pin':
        rst[0] = pm.curve(d=1, n=name, p=[(0, 0.0270211, 0), (-0.0158826, 0.0218603, 0), (-0.0256986, 0.00834981, 0), (-0.0256986, -0.00835026, 0), (-0.0158826, -0.0218607, 0), (0, -0.0270211, 0), (0.0158826, -0.0218607, 0),
                                          (0.0256986, -0.00835026, 0), (0.0256986, 0.00834981, 0), (0.0158826, 0.0218603, 0), (0, 0.0270211, 0), (0, 0.607018, 0), (-0.118932, 0.645661, 0), (-0.192436, 0.74683, 0), (-0.192436, 0.871884, 0),
                                          (-0.118932, 0.973053, 0), (0, 1.011698, 0), (0.118932, 0.973053, 0), (0.192436, 0.871884, 0), (0.192436, 0.74683, 0), (0.118932, 0.645661, 0), (0, 0.607018, 0)],
                          k=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])
    elif form == 'crosspin':
        rst[0] = pm.curve(d=1, n=name, p=[(0, 0.0500343, 0), (-0.0500343, 0, 0), (0, -0.0500343, 0), (0.0500343, 0, 0), (0, 0.0500343, 0), (0, 1.257438, 0), (-0.120872, 1.257438, 0),
                                          (-0.120872, 1.499182, 0), (-0.362616, 1.499182, 0), (-0.362616, 1.740926, 0), (-0.120872, 1.740926, 0), (-0.120872, 1.98267, 0), (0.120872, 1.98267, 0),
                                          (0.120872, 1.740926, 0), (0.362616, 1.740926, 0), (0.362616, 1.499182, 0), (0.120872, 1.499182, 0), (0.120872, 1.257438, 0), (0, 1.257438, 0)],
                          k=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])
    elif form == 'cube':
        rst[0] = pm.curve(d=1, n=name, p=[(-0.5, 0.5, -0.5), (0.5, 0.5, -0.5), (0.5, 0.5, 0.5), (-0.5, 0.5, 0.5), (-0.5, 0.5, -0.5), (-0.5, -0.5, -0.5), (0.5, -0.5, -0.5),
                                          (0.5, 0.5, -0.5), (-0.5, 0.5, -0.5), (-0.5, -0.5, -0.5), (-0.5, -0.5, 0.5), (-0.5, 0.5, 0.5), (0.5, 0.5, 0.5), (0.5, -0.5, 0.5),
                                          (-0.5, -0.5, 0.5), (-0.5, -0.5, -0.5), (0.5, -0.5, -0.5), (0.5, -0.5, 0.5)],
                          k=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
    elif form == 'triangle':
        rst[0] = pm.curve(d=1, n=name, p=[(0, 0.497911, 0), (-0.674025, -0.497911, 0), (0.674025, -0.497911, 0), (0, 0.497911, 0)],
                          k=[0, 1, 2, 3])
    elif form == 'diamondpin':
        rst[0] = pm.curve(d=1, n=name, p=[(0, 0.0835952, 0), (-0.0835952, 0, 0), (0, -0.0835952, 0), (0.0835952, 0, 0),
                                          (0, 0.0835952, 0), (0, 1.008552, 0), (-0.326239, 1.334791, 0), (0, 1.66103, 0),
                                          (0.326239, 1.334791, 0), (0, 1.008552, 0)], k=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
    elif form == 'hexagon':
        rst[0] = pm.curve(d=1, n=name, p=[(0.414019, 0.0, -1), (-0.414019, 0, -1), (-1, 0, -0.414019), (-1, 0, 0.414019),
                                          (-0.414019, 0, 1), (0.414019, 0, 1), (1, 0, 0.414019), (1, 0, -0.414019),
                                          (0.414019, 0, -1)], k=[0, 1, 2, 3, 4, 5, 6, 7, 8])
    elif form == 'lip':
        rst[0] = pm.circle(n=name, c=[0, 0, 0], nr=[0, 0, 1], sw=360, r=1, d=3, ut=0, tol=0.01, s=12, ch=0)[0]
        cvLs = [[0.18785, 0.38091, 0.0], [0.0, 0.12507, 0.0], [-0.18785, 0.38091, 0.0], [-0.90213, 0.07120, 0.0],
                [-1.04222, -0.00209, 0.0], [-0.90213, -0.09035, 0.0], [-0.52110, -0.28769, 0.0], [0.0, -0.38091, 0.0],
                [0.52110, -0.28769, 0.0], [0.90213, -0.09035, 0.0], [1.04222, -0.00209, 0.0], [0.90213, 0.07120, 0.0]]
        list(map(lambda i: rst[0].cp[i].set(cvLs[i][0], cvLs[i][1], cvLs[i][2]), range(12)))
    elif form == 'Eye':
        rst[0] = pm.curve(d=3, n=name, p=[([-6.57046234737, -2.68684513344, -2.45785996638e-15]),
                                          ([-7.13261542002, -1.55289293303e-15, -2.0205055052e-15]),
                                          ([-6.57046234737, 2.68684513344, -1.26466103408e-15]),
                                          ([-5.04301250688, 4.0313768254, -5.33423701453e-16]),
                                          ([-2.72163958787, 3.23831878984, -5.19265312134e-17]),
                                          ([-5.84260756747e-05, 2.42230306612, 5.37842776564e-16]),
                                          ([2.72178063184, 3.23848663844, 1.49010618821e-15]),
                                          ([5.04278651622, 4.03132065496, 2.32363816017e-15]),
                                          ([6.57089451076, 2.6868860558, 2.45799147489e-15]),
                                          ([7.13159295183, 5.51934689293e-16, 2.02021586354e-15]),
                                          ([6.57089451076, -2.6868860558, 1.26477436941e-15]),
                                          ([5.04278651622, -4.03132065496, 5.33372155853e-16]),
                                          ([2.72178063184, -3.23848663844, 5.19292158421e-17]),
                                          ([-5.8426075672e-05, -2.42230306612, -5.37875878084e-16]),
                                          ([-2.72163958787, -3.23831878984, -1.49002896383e-15]),
                                          ([-5.04301250688, -4.0313768254, -2.32371465045e-15]),
                                          ([-6.57046234737, -2.68684513344, -2.45785996638e-15]),
                                          ([-7.13261542002, -1.55289293303e-15, -2.0205055052e-15]),
                                          ([-6.57046234737, 2.68684513344, -1.26466103408e-15])],
                          k=[-0.125, -0.0625, 0.0, 0.0625, 0.125, 0.1875, 0.25, 0.3125, 0.375, 0.4375, 0.5, 0.5625, 0.625, 0.6874999999999999, 0.75, 0.8125, 0.875, 0.9375, 1.0, 1.0625, 1.125])
    elif form == 'Finger':
        rst[0] = pm.circle(n=name, c=[0, 0, 0], nr=[0, 0, 1], sw=360, r=1, d=3, ut=0, tol=0.01, s=8, ch=0)[0]
        cvLs = [([2.08110460065, 0.0, -2.08110460065]),
                ([-1.7763568394e-15, 0.0, -9.66382982837]),
                ([-2.08110460065, 0.0, -2.08110460065]),
                ([-9.66382982837, 0.0, -7.1054273576e-15]),
                ([-2.08110460065, 0.0, 2.08110460065]),
                ([-1.7763568394e-15, 0.0, 9.66382982837]),
                ([2.08110460065, 0.0, 2.08110460065]),
                ([9.66382982837, 0.0, -5.3290705182e-15]),
                ([2.08110460065, 0.0, -2.08110460065]),
                ([-1.7763568394e-15, 0.0, -9.66382982837]),
                ([-2.08110460065, 0.0, -2.08110460065])]
        list(map(lambda i: rst[0].cp[i].set(cvLs[i][0], cvLs[i][1], cvLs[i][2]), range(8)))
    elif form == 'Foot':
        rst[0] = pm.circle(n=name, c=[0, 0, 0], nr=[0, 0, 1], sw=360, r=1, d=3, ut=0, tol=0.01, s=8, ch=0)[0]
        cvLs = [([6.46143430945, -3.51626510985, -5.30795876314]),
                ([-4.92168523566e-15, -0.677263312252, -7.98519284539]),
                ([-6.46143430945, -3.51626510985, -5.30795876314]),
                ([-6.46145648162, -5.28434019544, 4.64329670962]),
                ([-6.46143430945, -3.6000032127, 15.1140753866]),
                ([-4.51429995311e-15, -0.669079682525, 18.8503117448]),
                ([6.46143430945, -3.6000032127, 15.1140753866]),
                ([6.46145648162, -5.28434019544, 4.64329670962]),
                ([6.46143430945, -3.51626510985, -5.30795876314]),
                ([-4.92168523566e-15, -0.677263312252, -7.98519284539]),
                ([-6.46143430945, -3.51626510985, -5.30795876314])]
        list(map(lambda i: rst[0].cp[i].set(cvLs[i][0], cvLs[i][1], cvLs[i][2]), range(8)))
    elif form == 'Jaw':
        rst[0] = pm.circle(n=name, c=[0, 0, 0], nr=[0, 0, 1], sw=360, r=1, d=3, ut=0, tol=0.01, s=8, ch=0)[0]
        cvLs = [([-2.62482745568, -1.69682008917, -3.76769746328e-16]),
                ([4.26679597871e-15, -2.7840592202, -6.18185329637e-16]),
                ([2.62482745568, -1.69682008917, -3.76769746328e-16]),
                ([3.71206658671, 2.78402209953, 6.18177087194e-16]),
                ([2.62482745568, 2.78404834781, 6.18182915481e-16]),
                ([7.27952347739e-15, 2.7840592202, 6.18185329637e-16]),
                ([-2.62482745568, 2.78404834781, 6.18182915481e-16]),
                ([-3.71206658671, 2.78402209953, 6.18177087194e-16]),
                ([-2.62482745568, -1.69682008917, -3.76769746328e-16]),
                ([4.26679597871e-15, -2.7840592202, -6.18185329637e-16]),
                ([2.62482745568, -1.69682008917, -3.76769746328e-16])]
        list(map(lambda i: rst[0].cp[i].set(cvLs[i][0], cvLs[i][1], cvLs[i][2]), range(8)))


    elif form == 'RoundSquare':
       
        rst[0] = pm.circle(n=name, c=[0, 0, 0], nr=[0, 0, 1], sw=360, r=1, d=3, ut=0, tol=0.01, s=8, ch=0)[0]
       
        cvLs = [([-5.771732851655997e-16, -2.9326523413879353, -2.9326523413879393]),
                 ([-1.0359713087382262e-15, 4.82305734569071e-29, -2.7649311432773533]),
                 ([-1.188903983262435e-15, 2.932652341387938, -2.9326523413879366]),
                 ([-1.0359713087382262e-15, 2.764931143277355, -6.117306980968354e-16]),
                 ([-8.830386342140174e-16, 2.9326523413879375, 2.9326523413879375]),
                 ([-1.3418366577866436e-15, 6.117306980968833e-16, 2.764931143277356]),
                 ([-8.830386342140174e-16, -2.9326523413879366, 2.932652341387935]),
                 ([-1.0359713087382262e-15, -2.7649311432773547, -3.058653490484177e-16]),
                 ([-5.771732851655997e-16, -2.9326523413879353, -2.9326523413879393]),
                 ([-1.0359713087382262e-15, 4.82305734569071e-29, -2.7649311432773533]),
                 ([-1.188903983262435e-15, 2.932652341387938, -2.9326523413879366])]
      
        list(map(lambda i: rst[0].cp[i].set(cvLs[i][0], cvLs[i][1], cvLs[i][2]), [x for x in range(8)]))

    elif form == 'ThickSquare':
         rst[0] = pm.curve(d=3, n=name, p=[([0.0762559759861727, 1.308625578453032e-28, -3.050238993994801]),
                                         ([0.0762559759861727, 1.7284687632637206, -3.050238993994801]),
                                         ([0.0762559759861727, 2.2440676132679003, -2.9630158388990204]),
                                         ([0.0762559759861727, 2.603541726083461, -2.603541726083461]),
                                         ([0.0762559759861727, 2.9630158388990204, -2.2440676132679007]),
                                         ([0.0762559759861727, 3.050238993994801, -1.7284687632637206]),
                                         ([0.0762559759861727, 3.050238993994801, 9.014843509261977e-17]),
                                         ([0.025418658662056903, 3.050238993994801, 9.014843509261977e-17]),
                                         ([-0.0762559759861725, 3.050238993994801, 9.014843509261977e-17]),
                                         ([-0.0762559759861725, 3.050238993994801, 9.014843509261977e-17]),
                                         ([-0.0762559759861725, 3.050238993994801, 9.014843509261977e-17]),
                                         ([0.025418658662056903, 3.050238993994801, 9.014843509261977e-17]),
                                         ([0.0762559759861727, 3.050238993994801, 9.014843509261977e-17]),
                                         ([0.0762559759861727, 3.050238993994801, 1.7284687632637206]),
                                         ([0.0762559759861727, 2.9630158388990204, 2.2440676132679003]),
                                         ([0.0762559759861727, 2.603541726083461, 2.603541726083461]),
                                         ([0.0762559759861727, 2.2440676132679003, 2.9630158388990195]),
                                         ([0.0762559759861727, 1.7284687632637206, 3.050238993994801]),
                                         ([0.0762559759861727, 1.308625578453032e-28, 3.050238993994801]),
                                         ([0.025418658662056903, 1.308625578453032e-28, 3.050238993994801]),
                                         ([-0.0762559759861725, 1.308625578453032e-28, 3.050238993994801]),
                                         ([-0.0762559759861725, 1.308625578453032e-28, 3.050238993994801]),
                                         ([-0.0762559759861725, 1.308625578453032e-28, 3.050238993994801]),
                                         ([0.025418658662056903, 1.308625578453032e-28, 3.050238993994801]),
                                         ([0.0762559759861727, 1.308625578453032e-28, 3.050238993994801]),
                                         ([0.0762559759861727, -1.7284687632637206, 3.050238993994801]),
                                         ([0.0762559759861727, -2.2440676132679003, 2.9630158388990195]),
                                         ([0.0762559759861727, -2.603541726083461, 2.603541726083461]),
                                         ([0.0762559759861727, -2.9630158388990204, 2.2440676132679003]),
                                         ([0.0762559759861727, -3.050238993994801, 1.7284687632637206]),
                                         ([0.0762559759861727, -3.050238993994801, 9.014843509261977e-17]),
                                         ([0.025418658662056903, -3.050238993994801, 9.014843509261977e-17]),
                                         ([-0.0762559759861725, -3.050238993994801, 9.014843509261977e-17]),
                                         ([-0.0762559759861725, -3.050238993994801, 9.014843509261977e-17]),
                                         ([-0.0762559759861725, -3.050238993994801, 9.014843509261977e-17]),
                                         ([0.025418658662056903, -3.050238993994801, 9.014843509261977e-17]),
                                         ([0.0762559759861727, -3.050238993994801, 9.014843509261977e-17]),
                                         ([0.0762559759861727, -3.050238993994801, -1.7284687632637206]),
                                         ([0.0762559759861727, -2.9630158388990204, -2.2440676132679007]),
                                         ([0.0762559759861727, -2.603541726083461, -2.603541726083461]),
                                         ([0.0762559759861727, -2.2440676132679003, -2.9630158388990204]),
                                         ([0.0762559759861727, -1.7284687632637206, -3.050238993994801]),
                                         ([0.0762559759861727, 1.308625578453032e-28, -3.050238993994801]),
                                         ([0.025418658662056903, 1.308625578453032e-28, -3.050238993994801]),
                                         ([-0.025418658662057798, 1.308625578453032e-28, -3.050238993994801]),
                                         ([-0.0762559759861725, 1.308625578453032e-28, -3.050238993994801]),
                                         ([-0.0762559759861725, 1.7284687632637206, -3.050238993994801]),
                                         ([-0.0762559759861725, 2.2440676132679003, -2.9630158388990204]),
                                         ([-0.0762559759861725, 2.603541726083461, -2.603541726083461]),
                                         ([-0.025418658662057798, 2.603541726083461, -2.603541726083461]),
                                         ([0.0762559759861727, 2.603541726083461, -2.603541726083461]),
                                         ([0.0762559759861727, 2.603541726083461, -2.603541726083461]),
                                         ([0.0762559759861727, 2.603541726083461, -2.603541726083461]),
                                         ([-0.025418658662057798, 2.603541726083461, -2.603541726083461]),
                                         ([-0.0762559759861725, 2.603541726083461, -2.603541726083461]),
                                         ([-0.0762559759861725, 2.9630158388990204, -2.2440676132679007]),
                                         ([-0.0762559759861725, 3.050238993994801, -1.7284687632637206]),
                                         ([-0.0762559759861725, 3.050238993994801, 9.014843509261977e-17]),
                                         ([-0.0762559759861725, 3.050238993994801, 1.7284687632637206]),
                                         ([-0.0762559759861725, 2.9630158388990204, 2.2440676132679003]),
                                         ([-0.0762559759861725, 2.603541726083461, 2.603541726083461]),
                                         ([-0.025418658662057798, 2.603541726083461, 2.603541726083461]),
                                         ([0.0762559759861727, 2.603541726083461, 2.603541726083461]),
                                         ([0.0762559759861727, 2.603541726083461, 2.603541726083461]),
                                         ([0.0762559759861727, 2.603541726083461, 2.603541726083461]),
                                         ([-0.025418658662057798, 2.603541726083461, 2.603541726083461]),
                                         ([-0.0762559759861725, 2.603541726083461, 2.603541726083461]),
                                         ([-0.0762559759861725, 2.2440676132679003, 2.9630158388990195]),
                                         ([-0.0762559759861725, 1.7284687632637206, 3.050238993994801]),
                                         ([-0.0762559759861725, 1.308625578453032e-28, 3.050238993994801]),
                                         ([-0.0762559759861725, -1.7284687632637206, 3.050238993994801]),
                                         ([-0.0762559759861725, -2.2440676132679003, 2.9630158388990195]),
                                         ([-0.0762559759861725, -2.603541726083461, 2.603541726083461]),
                                         ([-0.025418658662057798, -2.603541726083461, 2.603541726083461]),
                                         ([0.0762559759861727, -2.603541726083461, 2.603541726083461]),
                                         ([0.0762559759861727, -2.603541726083461, 2.603541726083461]),
                                         ([0.0762559759861727, -2.603541726083461, 2.603541726083461]),
                                         ([-0.025418658662057798, -2.603541726083461, 2.603541726083461]),
                                         ([-0.0762559759861725, -2.603541726083461, 2.603541726083461]),
                                         ([-0.0762559759861725, -2.9630158388990204, 2.2440676132679003]),
                                         ([-0.0762559759861725, -3.050238993994801, 1.7284687632637206]),
                                         ([-0.0762559759861725, -3.050238993994801, 9.014843509261977e-17]),
                                         ([-0.0762559759861725, -3.050238993994801, -1.7284687632637206]),
                                         ([-0.0762559759861725, -2.9630158388990204, -2.2440676132679007]),
                                         ([-0.0762559759861725, -2.603541726083461, -2.603541726083461]),
                                         ([-0.025418658662057798, -2.603541726083461, -2.603541726083461]),
                                         ([0.0762559759861727, -2.603541726083461, -2.603541726083461]),
                                         ([0.0762559759861727, -2.603541726083461, -2.603541726083461]),
                                         ([0.0762559759861727, -2.603541726083461, -2.603541726083461]),
                                         ([-0.025418658662057798, -2.603541726083461, -2.603541726083461]),
                                         ([-0.0762559759861725, -2.603541726083461, -2.603541726083461]),
                                         ([-0.0762559759861725, -2.2440676132679003, -2.9630158388990204]),
                                         ([-0.0762559759861725, -1.7284687632637206, -3.050238993994801]),
                                         ([-0.0762559759861725, 1.308625578453032e-28, -3.050238993994801])],
                  k=[0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 5.0, 5.0, 5.0, 6.0, 6.0, 6.0, 7.0, 7.0, 7.0, 8.0, 8.0, 8.0, 
                  9.0, 9.0, 9.0, 10.0, 10.0, 10.0, 11.0, 11.0, 11.0, 12.0, 12.0, 12.0, 13.0, 13.0, 13.0, 14.0, 14.0, 14.0, 15.0, 15.0, 15.0, 16.0, 16.0, 16.0, 
                  17.0, 17.0, 17.0, 18.0, 18.0, 18.0, 19.0, 19.0, 19.0, 20.0, 20.0, 20.0, 21.0, 21.0, 21.0, 22.0, 22.0, 22.0, 23.0, 23.0, 23.0, 24.0, 24.0, 24.0, 
                  25.0, 25.0, 25.0, 26.0, 26.0, 26.0, 27.0, 27.0, 27.0, 28.0, 28.0, 28.0, 29.0, 29.0, 29.0, 30.0, 30.0, 30.0, 31.0, 31.0, 31.0])
    elif form == 'SealHand':
    
        rst[0] = pm.circle(n=name, c=[0, 0, 0], nr=[0, 0, 1], sw=360, r=1, d=3, ut=0, tol=0.01, s=8, ch=0)[0]
       
        cvLs = [([-0.7847564139694754, 0.14454333714429202, -3.602530047627068]),
                 ([1.0711094347859833, 0.14454333714428996, -3.6487521502141638]),
                 ([3.5305603885499615, 0.14454333714428907, -3.40726156488441]),
                 ([4.428735282712921, 0.14454333714428996, -2.9508041263300698e-15]),
                 ([3.5305603885499615, 0.14454333714428907, 3.4072615648844207]),
                 ([1.0711094347859837, 0.14454333714428996, 3.6487523750213917]),
                 ([-0.7847564139694754, 0.14454333714429202, 3.6025300476270714]),
                 ([-0.7847634531447132, 0.14454333714429202, -2.3888597999719114e-15]),
                 ([-0.7847564139694754, 0.14454333714429202, -3.602530047627068]),
                 ([1.0711094347859833, 0.14454333714428996, -3.6487521502141638]),
                 ([3.5305603885499615, 0.14454333714428907, -3.40726156488441])] 
                  
        list(map(lambda i: rst[0].cp[i].set(cvLs[i][0], cvLs[i][1], cvLs[i][2]), [x for x in range(8)]))
        
    elif form == 'clover':
        rst[0] = pm.curve(d=1, n=name, p=[([3.680265932068953e-06, 4.166544527425766, -6.183239090573343]),
                                         ([-5.01854441244956e-07, 3.3594372212720445, -7.588673799293475]),
                                         ([-4.5166899996263005e-06, 1.9724311085935609, -8.665889669525434]),
                                         ([-6.022253334019306e-06, 3.7852232639487264e-06, -8.937558455318174]),
                                         ([-4.683974814558861e-06, -1.972422591841213, -8.665893454748705]),
                                         ([-5.01854441244956e-07, -3.3594320165900613, -7.588676165058011]),
                                         ([3.680265932068953e-06, -4.166540623914278, -6.183242047779012]),
                                         ([8.36424075018053e-06, -4.252173349481399, -4.252172927308873]),
                                         ([3.680265932068953e-06, -6.183242402643695, -4.166542161661226]),
                                         ([-5.01854441244956e-07, -7.58867379929348, -3.3594372212720445]),
                                         ([-4.5166899996263005e-06, -8.665888723219616, -1.972432054899375]),
                                         ([-6.022253334019306e-06, -8.93755845531818, -3.7852232639487264e-06]),
                                         ([-4.683974814558861e-06, -8.665891088984154, 1.9724249576057544]),
                                         ([-5.01854441244956e-07, -7.588676165058021, 3.35943201659006]),
                                         ([3.680265932068953e-06, -6.183242047779016, 4.166540623914278]),
                                         ([8.36424075018053e-06, -4.252168405834201, 4.252167461592094]),
                                         ([3.680265932068953e-06, -4.166544527425771, 6.183239090573346]),
                                         ([-5.01854441244956e-07, -3.3594372212720507, 7.58867379929348]),
                                         ([-4.5166899996263005e-06, -1.9724311085935677, 8.66588966952544]),
                                         ([-6.022253334019306e-06, -3.7852232690411254e-06, 8.93755845531818]),
                                         ([-4.683974814558861e-06, 1.9724225918412088, 8.665893454748707]),
                                         ([-5.01854441244956e-07, 3.359432016590052, 7.588676165058019]),
                                         ([3.680265932068953e-06, 4.16654062391427, 6.183242047779016]),
                                         ([8.36424075018053e-06, 4.252167460560227, 4.252167460560233]),
                                         ([8.36424075018053e-06, 4.252171932086439, 4.252173398398016]),
                                         ([3.680265932068953e-06, 6.183241929490776, 4.166541688508321]),
                                         ([-5.01854441244956e-07, 7.588673799293475, 3.3594372212720507]),
                                         ([-4.5166899996263005e-06, 8.665889669525434, 1.9724311085935657]),
                                         ([-6.022253334019306e-06, 8.937558455318174, 3.78522326841794e-06]),
                                         ([-4.683974814558861e-06, 8.665893454748705, -1.9724225918412093]),
                                         ([-5.01854441244956e-07, 7.588676165058011, -3.3594320165900533]),
                                         ([3.680265932068953e-06, 6.183242047779012, -4.166540623914271]),
                                         ([8.36424075018053e-06, 4.252167933713143, -4.2521679337131415]),
                                         ([3.680265932068953e-06, 4.166544527425766, -6.183239090573343])],
                          k=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33])
    elif form == 'iceStick':
        rst[0] = pm.curve(d=1, n=name, p=[([-1.7295770444949888e-07, -0.9479804586433058, 6.57775071817148]),
                                             ([-1.7295770319013387e-07, -0.806400369710483, 6.750283931824298]),
                                             ([-1.7295770274565222e-07, -0.5858841332030612, 6.887207165152519]),
                                             ([-1.7295770337533482e-07, -0.30801751875350103, 6.975117224401455]),
                                             ([-1.7295770225033004e-07, -5.9411817858865674e-08, 7.005408985308769]),
                                             ([-1.729577035049754e-07, 0.3080173999298658, 6.975117224401456]),
                                             ([-1.7295770233821063e-07, 0.585883895555788, 6.887207017592262]),
                                             ([-1.7295770241229092e-07, 0.8063999538277516, 6.750283784264042]),
                                             ([-1.7295770359757575e-07, 0.9479799833487538, 6.577750570611225]),
                                             ([-1.7295770359757575e-07, 0.9967651077957717, 6.386496017566562]),
                                             ([1.7295771779621302e-07, 0.9967649889721338, 5.829474767145322]),
                                             ([1.7295771127714816e-07, 0.9967649889721311, 0.005542030482833686]),
                                             ([1.7295771149524814e-07, -5.9411820771553866e-08, 0.005542030482833911]),
                                             ([1.729577117216298e-07, -0.9967651077957714, 0.005542030482834093]),
                                             ([1.7295771816661441e-07, -0.9967651077957689, 5.829474767145323]),
                                             ([-1.7295770319013387e-07, -0.9967649889721295, 6.386496017566562]),
                                             ([-1.7295770444949888e-07, -0.9479804586433058, 6.57775071817148])],
                          k=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])


    
    ChangeCurveColor(rst[0],colorNum)
    sz=size
    ChangeCurveTransform( rst[0], 'scale', dt.Vector(sz,sz,sz), 1 )
    if exGrp:
        exNm='%sGrp'% name
        if pm.objExists(exNm):
            rst[1]=pm.createNode( 'transform', n='%sOffGrp'% name)
        else: rst[1]=pm.createNode( 'transform', n=exNm )
        pm.parent(rst[0],rst[1])
    return rst


# Pair Blend
def PairBlend(Target, **op):
    if op.get('t') or op.get('r'):
        if not Target.hasAttr('pbw'):
            Target.addAttr('pbw', min=0, max=1, k=1)
        PB = pm.createNode('pairBlend', n='%sPB' % Target)
        PB.ri.set(1)
        if Target.t.inputs(p=1):
            Target.t.inputs(p=1)[0] >> PB.it2
            Target.t.inputs(p=1)[0] // Target.t
        if Target.tx.inputs(p=1):
            Target.tx.inputs(p=1)[0] >> PB.itx2
        if Target.ty.inputs(p=1):
            Target.ty.inputs(p=1)[0] >> PB.ity2
        if Target.tz.inputs(p=1):
            Target.tz.inputs(p=1)[0] >> PB.itz2
        if Target.r.inputs(p=1):
            Target.r.inputs(p=1)[0] >> PB.ir2
            Target.r.inputs(p=1)[0] // Target.r
        if Target.rx.inputs(p=1):
            Target.rx.inputs(p=1)[0] >> PB.irx2
        if Target.ry.inputs(p=1):
            Target.ry.inputs(p=1)[0] >> PB.iry2
        if Target.rz.inputs(p=1):
            Target.rz.inputs(p=1)[0] >> PB.irz2
        Target.pbw >> PB.w
        if op.get('t'):
            PB.itx1.set(Target.tx.get())
            PB.ity1.set(Target.ty.get())
            PB.itz1.set(Target.tz.get())
            PB.otx >> Target.tx
            PB.oty >> Target.ty
            PB.otz >> Target.tz
        if op.get('r'):
            PB.irx1.set(Target.rx.get())
            PB.iry1.set(Target.ry.get())
            PB.irz1.set(Target.rz.get())
            PB.orx >> Target.rx
            PB.ory >> Target.ry
            PB.orz >> Target.rz
    else:
        pm.warning('we need flag t or r')
    return PB


# ---Mcon---
def Mcon(src, tg, **op):
    if op.get('pos'): pm.matchTransform(tg, src, pos=1, rot=1, scl=0)
    mm = pm.createNode('multMatrix', n='%sMM' % tg)
    dm = pm.createNode('decomposeMatrix', n='%sDM' % tg)
    rtn = [None, None]
    if op.get('pvtCalc'):
        tgRotatePivot = tg.getRotatePivot(space='transform')
        tg.setScalePivot(tgRotatePivot, space='transform')
        tgScalePivotMtx = dt.Matrix()
        tgScalePivotMtx[3] = tg.getScalePivot(space='transform')
        mm.i[0].set(tgScalePivotMtx)
        mm.i[1].set(tg.getMatrix(worldSpace=1))
        mm.i[1].set(tg.getMatrix(worldSpace=1))
        mm.i[2].set(src.getMatrix(worldSpace=1).inverse())
        src.wm >> mm.i[3]
        tg.pim >> mm.i[4]
        tgTMRPM = dt.Matrix()
        tgTMRPM[3] = tg.transMinusRotatePivot.get()
        mm.i[5].set(tgTMRPM)
    else:
        mm.i[0].set(tg.getMatrix(worldSpace=1))
        mm.i[1].set(src.getMatrix(worldSpace=1).inverse())
        src.wm >> mm.i[2]
        tg.pim >> mm.i[3]
    mm.o >> dm.imat
    if op.get('t'):
        dm.ot >> tg.t
    if op.get('r'):
        if tg.nodeType() == 'joint':
            eq = pm.createNode('eulerToQuat', n='%sEQ' % tg)
            qi = pm.createNode('quatInvert', n='%sQI' % tg)
            qp = pm.createNode('quatProd', n='%sQP' % tg)
            qe = pm.createNode('quatToEuler', n='%sQE' % tg)
            tg.jo >> eq.irt
            eq.oq >> qi.iq
            dm.oq >> qp.iq1
            qi.oq >> qp.iq2
            qp.oq >> qe.iq
            qe.ort >> tg.r
        else:
            dm.attr('or') >> tg.r
    if op.get('s'):
        dm.os >> tg.s
        dm.osh >> tg.sh


# Ycms-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
def addNPO(objs=None, GrpName=None, *args):
    npoList = []

    if not objs:
        objs = pm.selected()

    if not isinstance(objs, list):
        objs = [objs]

    for obj in objs:
        oParent = obj.getParent()
        oTra = pm.createNode("transform",
                             n=obj.name().replace("Grp", "") + GrpName,
                             p=oParent,
                             ss=True)

        oTra.setTransformation(obj.getMatrix())
        pm.parent(obj, oTra)
        npoList.append(oTra)

    return npoList


def rotate_components(rx, ry, rz, nodes=None):
    if nodes is None:
        nodes = pm.ls(sl=True) or []
    else:
        nodes = pm.ls(nodes)

    for node in nodes:
        # print node
        pivot = pm.xform(node, q=True, rp=True, ws=True)
        pm.rotate(
            "{0}.cv[*]".format(node), rx, ry, rz, r=True, p=pivot, os=True, fo=True
        )


def translate_components(tx, ty, tz, nodes=None):
    if nodes is None:
        nodes = pm.ls(sl=True) or []
    else:
        nodes = pm.ls(nodes)
    for node in nodes:
        # print node
        pivot = pm.xform(node, q=True, rp=True, ws=True)
        pm.move("{0}.cv[*]".format(node), tx, ty, tz, relative=True, objectSpace=True, worldSpaceDistance=True)

def PosCopy(src, tg):
    tmpCons = pm.parentConstraint(src, tg)
    pm.delete(tmpCons)

def jntList(objs,joint_count):
    if not objs:
        objs = pm.selected()
    if not isinstance(objs, list):
        objs = [objs]
    if joint_count:
        for obj in objs:
            pm.select(obj)
            selectNodesTypeBelow('joint')
            List = pm.ls(sl=1)
            Spinejnt_List = List[:(joint_count)]
            pm.select(Spinejnt_List)
            result = pm.ls(sl=1)
    if not joint_count:
        for obj in objs:
            pm.select(obj)
            selectNodesTypeBelow('joint')
            result = pm.ls(sl=1)
    return result

def selectNodesTypeBelow(nodeType):
    nodesToSelect = []
    nodes = findNodesTypeBelow(nodeType)
    for n in nodes:
        nodesToSelect.append(n)
    mc.select(nodesToSelect, r=1)
    return True

def findNodesTypeBelow(nodeType):
    mc.select(hi=1)
    sel = mc.ls(sl=1, type=nodeType)
    return sel

def CrvFromJnt(JntList):
    pointList = []
    for x in JntList:
        tg = pm.xform(x, q=1, t=1, ws=1)
        pointList.append(tg)
    kList = []
    for i in range(len(pointList)):
        kList.append(i)
    Curve = pm.curve(p=pointList, k=kList, d=1)
    return Curve

def MakeBindPreMtxCluster(ev=None):
    slls=pm.ls(sl=1,l=1)
    clustHdlLs=[]
    mesh=[]
    for sl in slls:
        sh=pm.listRelatives(sl,s=1,f=1)[0]
        cfmNode=pm.nodeType(sh)
        if cfmNode=='mesh': mesh.append(sl)
        elif cfmNode=='clusterHandle': clustHdlLs.append(sl)
    if len(clustHdlLs)==0 and len(mesh)==0:
        pm.error('메쉬나 클러스터를 선택하여야 스크립트가 실행됩니다.')
    if len(mesh):
        meshSlClst=pm.cluster(mesh)
        clustHdlLs.append(meshSlClst[1])
    for ch in clustHdlLs:
        sh=pm.listRelatives(ch,s=1)[0]
        clst=pm.listConnections('%s.worldMatrix[0]'% ch)[0]
        pm.setAttr('%s.rotatePivot'% ch, 0, 0, 0)
        pm.setAttr('%s.scalePivot'% ch, 0, 0, 0)
        pm.setAttr('%s.origin'% sh, 0, 0, 0)
        clstGrp=pm.createNode('transform',n='%sGrp'% ch)
        clstIvsMtx=pm.createNode('transform',n='%sZeroMtx'% ch,p=clstGrp)
        pm.parent(ch,clstGrp)
        pm.connectAttr('%s.worldInverseMatrix'% clstIvsMtx,'%s.bindPreMatrix'% clst)
    return clstGrp

def JntAxesChange(Axes,SAO,JntList):
    for x in JntList:
        pm.select(x)
        pm.joint(e=1  ,oj =Axes ,secondaryAxisOrient= SAO,ch =1 ,zso=1)
    pm.setAttr ("%s.jointOrientX"%JntList[-1], 0)
    pm.setAttr ("%s.jointOrientY"%JntList[-1], 0)
    pm.setAttr ("%s.jointOrientZ"%JntList[-1], 0)

